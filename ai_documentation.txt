For point 5 in the homework.

Prompt: can you help me with ideas on how to test (through pytest) these funcitons, please? ** I inserted the functions directly from the code **

Gen-AI answer:
Below are practical ideas and examples for testing each function with pytest, including what properties to check, possible mocks, and edge-case scenarios.

Because the functions involve FFTs, whitening, and WAV writing, most correct-ness checks are done via expected behavior / invariants / shapes, rather than exact output values.

✅ General Notes

Use small artificial signals (e.g., sinusoids, random noise) where the math is predictable.

When the function depends on external objects (e.g., interp_psd), mock them.

WAV writing should be checked without actually playing sound—just verify correct dtype, scaling, range, and that file I/O is performed correctly.

✅ Tests for whiten()
Key properties to test

Output shape == input shape

Handles constant PSD

Whitening reduces amplitude of high-PSD signals (qualitative)

No NaNs or infinities

interp_psd is called properly → mock it

Example pytest
import numpy as np
import pytest

from yourmodule import whiten

def test_whiten_shape():
    np.random.seed(0)
    strain = np.random.randn(4096)
    
    # mock PSD function (flat PSD = 1 everywhere)
    interp_psd = lambda f: np.ones_like(f)
    
    dt = 1/4096.
    
    w = whiten(strain, interp_psd, dt)
    assert w.shape == strain.shape

def test_whiten_constant_psd_preserves_energy_order():
    np.random.seed(0)
    strain = np.random.randn(4096)
    interp_psd = lambda f: np.ones_like(f)
    dt = 1/4096.

    w = whiten(strain, interp_psd, dt)

    # whitened data should have RMS different but finite
    assert np.isfinite(w).all()
    assert not np.allclose(w, strain)  # should be changed

def test_whiten_nan_psd():
    strain = np.random.randn(4096)
    interp_psd = lambda f: np.full_like(f, np.nan)
    dt = 1/4096.

    with pytest.raises(ValueError):
        w = whiten(strain, interp_psd, dt)


If required, you can modify code to raise errors for bad PSD input; tests enforce that.

✅ Tests for write_wavfile()
What to test

Accepts correct arguments

Normalization is correct

Output is in int16 range

Writes a file

Use tmp_path fixture:

from yourmodule import write_wavfile
from scipy.io import wavfile
import numpy as np

def test_write_wavfile(tmp_path):
    filename = tmp_path / "test.wav"
    fs = 4096
    data = np.random.randn(4096)

    write_wavfile(filename, fs, data)

    # file saved?
    assert filename.exists()

    # check data inside
    rate, d = wavfile.read(filename)
    assert rate == fs
    assert d.dtype == np.int16
    assert np.max(np.abs(d)) <= 32767


Edge case:

Zero input → np.max(abs(data)) == 0 will divide by zero. Test that.

def test_write_wavfile_zero_input(tmp_path):
    filename = tmp_path / "zero.wav"
    fs = 4096
    data = np.zeros(1000)

    # Should not crash
    write_wavfile(filename, fs, data)
    assert filename.exists()


You might want to update implementation to handle divide-by-zero.

✅ Tests for reqshift()
What to test

Output shape = input shape

Known shifts → predictable behavior

Zero shift gives same result

No NaN

Signal energy preserved (roughly)

Example:
import numpy as np
from yourmodule import reqshift

def test_reqshift_shape():
    data = np.random.randn(4096)
    shifted = reqshift(data, fshift=100, sample_rate=4096)
    assert shifted.shape == data.shape

def test_reqshift_zero_shift_is_identity():
    data = np.random.randn(4096)
    shifted = reqshift(data, fshift=0, sample_rate=4096)
    assert np.allclose(shifted, data)

def test_reqshift_no_nan():
    data = np.random.randn(4096)
    shifted = reqshift(data)
    assert np.isfinite(shifted).all()

def test_reqshift_known_sine_shift():
    fs = 4096
    t = np.arange(4096) / fs
    f = 200
    data = np.sin(2*np.pi*f*t)

    shifted = reqshift(data, fshift=100, sample_rate=fs)

    # After shift, the peak frequency should be ~300 Hz
    X = np.fft.rfft(shifted)
    freqs = np.fft.rfftfreq(len(data), 1/fs)
    peak = freqs[np.argmax(np.abs(X))]
    assert np.isclose(peak, f+100, atol=5)  # wide tolerance

✅ Optional fixture for deterministic data

If multiple tests need the same signal:

@pytest.fixture
def gaussian_signal():
    np.random.seed(0)
    return np.random.randn(4096)

✅ Summary Table
Function	Testing strategy
whiten	shape, no NaN, mock PSD, energy change, raises errors
write_wavfile	writes file, dtype=int16, scaling valid, zero-input handling
reqshift	identity shift, freq peak moves, shape preserved, no NaN

If you want, I can also:
✅ create a tests/ directory layout
✅ add conftest.py
✅ add mocks for PSD (with pytest-mock)
✅ include CI example (GitHub Actions)

Just tell me!
